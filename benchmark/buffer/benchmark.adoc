= Buffer benchmark

Benchmark for thread-safe static-size buffers.
The following implementations are checked:

- Read/Write mutex based with linear search (baseline)
- Read/Write mutex based with ls in control array
- atomic with ls in control array
- atomic ringbuffer-like
- atomic ffs based

== Buffer requirements

The buffers need to implement the following operations on arbitrary type `T`, which is what they are storing.

constexpr _size_type_ buffer<T>::__capacity()__::

_bool_ buffer<T>::__was_full()__::
Query the buffer and determine if it is full at the moment.

_auto_ buffer<T>::__insert(T&& data)__::
Move given _data_ into the buffer and return smart reference to it.
If there is not enough space in the buffer, return the null element.
The requirements for the smart reference are in the <<smrt_ref>> section.

_void_ buffer<T>::__remove(size_type idx)__::
Removes the element at index _idx_.
The element at _idx_ needs to be currently alive, so it is not advised to call this member function as-is.

_void_ buffer<T>::__checked_remove(size_type idx)__::
Removes the element at index _idx_, if it exists.

[#smrt_ref]
=== Smart reference requirements

The following refer to this type as `ref_t`.

null element::
+
The type (stem:[bb T]) has to contain a null element stem:[epsilon].
For this the followings needs to hold:
+
[lowerroman]
. stem:[epsilon = epsilon]
. stem:[AA r in bb T \\ {epsilon} : r != epsilon].

_bool_ operator==(const ref_t& a, const ref_t& b)::
Two references are equal if the point to the same slot in the buffer.

_T&_ ref_t::__operator*()__::
Returns a reference to the given object.
Destructing this object results in undefined behavior.

_void_ ref_t::__remove()__::
Removes the element from the buffer.
Any access to this reference that is not destruction results in undefined behavior.

_void_ ref_t::__keep_memory()__::
Do not remove the element from the buffer, once this reference is reaped.

ref_t::__~ref_t()__ noexcept::
Unless keep_memory() has been called, removes the referred element from the buffer.
